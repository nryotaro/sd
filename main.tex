\documentclass{jlreq}
\usepackage[bookmarks=true,bookmarksnumbered=true,
pdftitle={システム設計},
pdfauthor={nryotaro},
pdfkeywords={System Design; Interview},
pdflang=ja-JP
]{hyperref}
\usepackage{main}
\addbibresource{main.bib}
\begin{document}
\title{システム設計}
\author{nryotaro}
\date{\today}
\maketitle
\tableofcontents
\part{基本}
\begin{section-bib}{面接の流れ}
  システム全体のアーキテクチャを問われるときは、Propose a Design, Talk about trade-offs, Discuss design choices, Limitationsの4部構成で話す\cite{lc-high}。
\end{section-bib}
%
\begin{section-bib}{モノリスではなくマイクロサービスで設計する}
  % モノリスとマイクロサービスの比較を書く。
  課題はモノリスで設計するには複雑すぎるので、マイクロサービスの設計を提案する\cite{lc-aa}。
  \subsection{設問}
  \begin{exercise}
  \item モノリスと比べたときのマイクロサービスの利点と欠点をのべよ。\label{exe:monolith-micro}  
  \end{exercise}
  \subsection{解説}
  \subsubsection*{\ref{exe:monolith-micro}}
  たとえば、複数の技術を適材適所に使えるが、プロセス内の通信がネットワーク越しのAPI呼び出しになる分のレイテンシーが発生する\cite{lc-aa}。  
\end{section-bib}
%
\begin{section-bib}{Queue}
  複数のサービスへ同期的に通信するトランザクションは、通信を非同期にすれば応答の待機時間を短くできる。
  しかし、対向サービスに障害があれば非同期通信が失敗しても、トランザクションは別のサービスにリクエストを送る。
  サービスをキューを介して通信させることで、対向サービスと一時的につながらない間でも、キューにメッセージを蓄積でき、メッセージの消失を防ぐことができる\cite{lc-isc}。
  \subsection{設問}
  \begin{exercise}
  \item 2つのサービスが直接ではなくキューを介して非同期通信する利点をのべよ。また、利点を満足するためのキューへの要件は何か。\label{exe:async-queue}
  \item 主要なメッセージキューのミドルウェアを挙げ、向き、不向きを比較せよ。\label{exe:queue-compare}
  \end{exercise}
  \subsection{解説}
  \subsubsection*{\ref{exe:async-queue}}
  対向システムの障害時のリクエストをキューに一時的に保存できるため、失敗するリクエストを減らすことができる\cite{lc-isc}。
  キューは、中継対象のシステムより、安定していなけばならない。
  キューでなくロードバランサでも負荷分散を実現できるので、キューの利点として負荷分散を先にあげるのはよくないだろうか。
  \subsubsection*{\ref{exe:queue-compare}}
  Kafka, RabbitMQ, ActiveMQがある\cite{lc-isc}。
\end{section-bib}
\begin{section-bib}{双方向通信}
  ロングポーリングは、タイムアウトまでの時間を長くし、サーバからの応答を待つ。
  このとき、サーバーはクライアウントのタイムアウトを検知できない\cite{sdi}。
  \subsection{設問}
  \begin{exercise}
    \item ロングポーリングとWebSocketそれぞれの使いどころを述べよ。
  \end{exercise}
\end{section-bib}
\begin{section-bib}{キャッシュ}
  \subsection{Consistent Hashing}
  キャッシュを複数のノードに分散して保存するとき、ハッシュ関数をキーに適用し、値が格納されたノードを特定できる。
  このとき、参加するノードが変われば、キャッシュされたデータを再配置しなければならない。
  コンシステントハッシュ法は、円環上のハッシュ値とノードを配置したとき、ハッシュ値から時計回りに出発し最初に出会うノードに値を格納する\cite{sdi}。
  このとき、ノードを追加、削除した場合に変更が起きた箇所付近の弧のノードだけをリバランスすればよく、再配置すべきデータ量を減らすことができる。
  ノードの数が少ないと、再配置した結果、ノードごとのデータ量が偏るおそれがある。
  ノードの数がおおいほど、偏りを防げるため、1つのノードに対応する複数の仮想的なノードを円環上に配置することで、偏りを抑止できる。
  
  Consistent Hasingは、CDNのようなインタネット規模のキャッシュシステムで使われる一方で、データベースのパーティショニングではうまくいかない\cite{DBLP:journals/corr/LampingV14}。
  \subsection{Cache Eviction}
  Cache evictionの方式にはTTL、FIFO, LFU, LRU, LFRUなどがある\cite{lc-cache}。
\end{section-bib}
\begin{section-bib}{分散ファイルシステム}
  CDNを使えば、Amazon S3などの分散ファイルシステムに配置したデータを高速に配信できる\cite{lc-databases}。
\end{section-bib}

\begin{section-bib}{データベース}
  % NOSQLの代表例, document指向の使いどろこ、列指向のつかいどころを説明させる。
  ACIDのConsistency(一貫性)は、データに常に真でなければならない不変性があることである\cite{ddia}。
  属性が多いデータはドキュメント指向データベースが、クエリのパターンが少ないがデータ量が多いときは列指向データベースがよい\cite{lc-databases}。
  ドキュメント指向データベースの例にMongoDBやCouchbaseが、列指向データベースの例にCassandraやHBaseがある。
  \subsection{設問}
  \begin{exercise}
  \item ACIDの各アルファベットが示す特性について説明せよ。
  \end{exercise}  
\end{section-bib}
\begin{section-bib}{Rate Limiting}
  \subsection{Leaky Bucket}
  蓄えられる未処理のリクエスト数と一定時間に処理できるリスエスト数の2つパラメータでリクエストを制御する。
  蓄えられている未処理のリクエストから一定時間内の固定数のリクエストを処理する。
  蓄えられるリクエスト数を越えてリクエストが届く場合リクエストを破棄する。
  パラメタ数が少なくチューニングが簡単だが、蓄えられるリクエスト数が一杯になるまでは、一定時間に処理できる分量以上のリクエストを受けつけてしまう。
  \subsection{Fixed Window}
  一定時間のウィンドウ内に処理するリクエスト数の上限を決め、それを越えるリクエストを破棄する。
  2つのウィンドウをまたいだ時刻にリクエストが多く到着する場合、ウィンドウサイズを越えたリクエスト数がウィンドウサイズと同じ時間内に処理されるおそれがある。
  \subsection{Sliding Window}
  一定時間のウィンドウをスライドさせ、Fixed windowのウィンドウをまたいだ場合に上限以上のリクエストが処理される問題をふせぐ。
  Fixed Windowよりも制御に多く計算リソースが必要である。
  \subsection{設問}
  \begin{exercise}
  \item リクエストの上限を制御するためのアルゴリズムをいくつか挙げ、その特徴をのべよ。
  \end{exercise}    
\end{section-bib}
\part{Case Studies}
\end{document}