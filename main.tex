\documentclass{jlreq}
\usepackage[bookmarks=true,bookmarksnumbered=true,
pdftitle={システム設計},
pdfauthor={nryotaro},
pdfkeywords={System Design; Interview},
pdflang=ja-JP
]{hyperref}
\usepackage{main}
\addbibresource{main.bib}
\begin{document}
\title{システム設計}
\author{nryotaro}
\date{\today}
\maketitle
\tableofcontents
\part{基本}
\begin{section-bib}{面接の流れ}
  システム全体のアーキテクチャを問われるときは、Propose a Design, Talk about trade-offs, Discuss design choices, Limitationsの4部構成で話す\cite{lc-high}。
\end{section-bib}
%
\begin{section-bib}{モノリスではなくマイクロサービスで設計する}
  % モノリスとマイクロサービスの比較を書く。
  課題はモノリスで設計するには複雑すぎるので、マイクロサービスで設計する\cite{lc-aa}。
  \subsection{設問}
  \begin{exercise}
  \item モノリスと比べたときのマイクロサービスの利点と欠点をのべよ。\label{exe:monolith-micro}  
  \end{exercise}
  \subsection{解説}
  \subsubsection*{\ref{exe:monolith-micro}}
  たとえば、複数の技術を適材適所に使えるが、プロセス内の通信がネットワーク越しのAPI呼び出しになる分のレイテンシーが発生する\cite{lc-aa}。  
\end{section-bib}
%
\begin{section-bib}{Queue}
  複数のサービスへ同期的に通信するトランザクションは、通信を非同期にすれば応答の待機時間を短くできる。
  しかし、対向サービスに障害があれば非同期通信が失敗しても、トランザクションは別のサービスにリクエストを送る。
  サービスをキューを介して通信させることで、対向サービスと一時的につながらない間でも、キューにメッセージを蓄積でき、メッセージの消失を防ぐことができる\cite{lc-isc}。
  \subsection{設問}
  \begin{exercise}
  \item 2つのサービスが直接ではなくキューを介して非同期通信する利点をのべよ。また、利点を満足するためのキューへの要件は何か。\label{exe:async-queue}
  \item 主要なメッセージキューのミドルウェアを挙げ、向き、不向きを比較せよ。\label{exe:queue-compare}
  \end{exercise}
  \subsection{解説}
  \subsubsection*{\ref{exe:async-queue}}
  対向システムの障害時のリクエストをキューに一時的に保存できるため、失敗するリクエストを減らすことができる\cite{lc-isc}。
  キューは、中継対象のシステムより、安定していなけばならない。
  キューでなくロードバランサでも負荷分散を実現できるので、キューの利点として負荷分散を先にあげるのはよくないだろうか。
  \subsubsection*{\ref{exe:queue-compare}}
  Kafka, RabbitMQ, ActiveMQがある\cite{lc-isc}。
\end{section-bib}
\begin{section-bib}{双方向通信}
  ロングポーリングは、タイムアウトまでの時間を長くし、サーバからの応答を待つ。
  このとき、サーバーはクライアウントのタイムアウトを検知できない\cite{sdi}。
  \subsection{設問}
  \begin{exercise}
    \item ロングポーリングとWebSocketそれぞれの使いどころを述べよ。
  \end{exercise}
\end{section-bib}
\begin{section-bib}{キャッシュ}
  \subsection{Consistent Hashing}
  キャッシュを複数のノードに分散して保存するとき、ハッシュ関数をキーに適用し、値が格納されたノードを特定できる。
  このとき、参加するノードが変われば、キャッシュされたデータを再配置しなければならない。
  コンシステントハッシュ法は、円環上のハッシュ値とノードを配置したとき、ハッシュ値から時計回りに出発し最初に出会うノードに値を格納する\cite{sdi}。
  このとき、ノードを追加、削除した場合に変更が起きた箇所付近の弧のノードだけをリバランスすればよく、再配置すべきデータ量を減らすことができる。
  ノードの数が少ないと、再配置した結果、ノードごとのデータ量が偏るおそれがある。
  ノードの数がおおいほど、偏りを防げるため、1つのノードに対応する複数の仮想的なノードを円環上に配置することで、偏りを抑止できる。
  
  Consistent Hasingは、CDNのようなインタネット規模のキャッシュシステムで使われる一方で、データベースのパーティショニングではうまくいかない\cite{DBLP:journals/corr/LampingV14}。
  \subsection{Cache Eviction}
  Cache evictionの方式にはTTL、FIFO, LFU, LRU, LFRUなどがある\cite{lc-cache}。
\end{section-bib}
\begin{section-bib}{分散ファイルシステム}
  CDNを使えば、Amazon S3などの分散ファイルシステムに配置したデータを高速に配信できる\cite{lc-databases}。
\end{section-bib}

\begin{section-bib}{データベース}
  % ACIDの説明、NOSQLの代表例, document指向の使いどろこ、列指向のつかいどころを説明させる。
%   \subsection{設問}
%   \begin{exercise}
%   \item 
%   \end{exercise}
% \end{section-bib}
\part{ケーススタディ}
\end{document}